---
title: "Working with Cytometry Data in R"
subtitle: "Mass Cytometry Course 2019"
author: "Benjamin Reisman"
date: "March 22, 2019"
output:
  slidy_presentation: default
  code_folding: "hide"
editor_options:
  chunk_output_type: console
widescreen: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, cache = TRUE)
options(tinytex.verbose = TRUE)

```

## Why Use R? 

_"R is a free software environment for statistical computing and graphics"_

Compared to Commercial Flow Cytometry Software, R has the following advantages:

>- Reproducible (Data + Code = Figures)
>- Flexible (This presentation was created in R!)
>- Nice Graphics (ggplot2)
>- Great for analysis pipelines and frequently used workflows
>- Newest analysis techniques
>- Free!

## Goals of this talk:
In R, things that look hard are easy, but things that look easy are (a little) hard.

>- Demonstrate why you might want to work in R
>- Overcoming the biggest obstacles to working in R
>    - Getting data into R
>    - Tidying data into the right format for analysis
>- Introduce some advanced analysis techniques
>- Provide examples and links to resources for learning more. 

## Representing Data in R

>- Matrix: An $n*m$ array of items, all of the single class
>- Data Frame: An $n*m$ array of items, but each column can be a different class

_Example: The iris dataset: measurements of 50 flowers of 3 species of iris_ 
```{r introduce iris}
head(iris)

library(ggplot2)
ggplot(iris, aes(x= Petal.Length, y = Petal.Width, col = Species)) + 
  geom_point()
```


## Representing Data in R: Data Frames
Data Frame: An $n*m$ array of items, but each column can be a different class
```{r}
class(iris)
str(iris)
```

## Representing Data in R: Matricies (1)
- Matrix: An $n*m$ array of items, all of the single class
```{r}
iris_matrix <- as.matrix(iris)
head(iris_matrix)
str(iris_matrix)
```
that doesn't look right...

## Representing Data in R: Matricies (2)
- Matrix: An $n*m$ array of items, all of the single class
```{r}
#only the numeric columns, 1:4
iris_matrix <- as.matrix(iris[1:4])
head(iris_matrix)
str(iris_matrix)
```

## Defining Tidy Data

To work with data in R, it's best to have 'tidy data,' which meets the following criteria:

>1. Each variable ['feature'] must have its own column.
>2. Each observation ['cell'] must have its own row. 
>3. Each value must have its own cell ['entry'].

![](https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png){ width=50% }

...but cytometry data is not usually tidy. 

_For more information, see_: Wickham, Hadley. "Tidy data." _Journal of Statistical Software_ 59.10 (2014): 1-23.

## Representing Flow Cytometry Data in R

A number of specialized classes have been developed to represent high dimensional bioinformatics data: 

>- Biocondutor:
>    - `SummarizedExperiment` - created to represent genetic data (RNAseq, microarray, etc...)
>- `flowcore` (RGlab)
>    - `FlowFrame` - Representation of an FCS file in R
>    - `FlowSet` - Container for multiple FlowFrames + Metadata 
>- `flowWorkspace` (RGlab)
>    - `GatingSet`- A FlowSet + associated gating hierarchy

## Representing Flow Cytometry Data in R
<div style="float: left; width: 50%;">

A cytometry experiment may include:

- FCS files
- Compensations (FACS)
- Transformations
- Panels
- Gates + Populations
- Metadata


</div>
<div style="float: right; width: 50%;">
... but those aren't neatly represented in R:



Traditional Object | FlowCore Object | R Equivalent
-------------------|-----------------|-------------
FCS File           | FlowFrame      | Matrix
Bunch of FCS File  | FlowSet        | List of matrices + pData
Gated Experiment   | Gatingset      | -
</div>

## Itâ€™s easy to get flow cytometry data into R with the right tools

First we'll need to load a few packages...
```{r warning = FALSE, message = FALSE}
library(CytobankAPI) #connects to cytobank
library(flowWorkspace)#loads flowcore, flowWorkspace
library(CytoML) #Used to read in gating files
library(cytotidyr) #for importing cytobank experiments, and tidying
library(dplyr) #for manipulating data
library(tidyr) #for rearranging data from wide to long
library(ggplot2)
```

and find our files...
```{r}
fcs_paths <- list.files(pattern = ".fcs", recursive = T)
print(fcs_paths)
```

## Cytotidyr and CytobankAPI can be used to work between Cytobank and R

Using `CytobankAPI` and `Cytotidyr` we'll read in our experiment information from cytobank.
This includes:

- gates
- transformations
- panels
- sample tags. 
```{r cache = TRUE, warning = FALSE, eval = F}
token <- "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJqdGkiOiIwNTY2MjlhYjc0YzA2ZWE3Njk0YzQ2NWM2YWM3MWIwMyIsImV4cCI6MTU1MjUxNjIxNywidXNlcl9pZCI6MTQ3LCJhdWQiOiJjeXRvYmFua19hcGlfdjFfdXNlcnMiLCJpYXQiOjE1NTI0ODc0MTcsImlzcyI6Imh0dHBzOi8vdmFuZGVyYmlsdC5jeXRvYmFuay5vcmcvIiwibmJmIjoxNTUyNDg3NDE3LCJzdWIiOiJjeXRvYmFua19hcGlfdjEifQ.MXnBJnOx4O2WutoK3U8OgNtaAo9pxnzKBNl8v8szGCY"
cyto_session <- authenticate("vanderbilt", auth_token = token)
experiment.id <- 29958
exp_info <- fetchCytobankExperiment(cyto_session, experiment.id)
```

```{r, echo = F}
#saveRDS(exp_info, "exp_info.rds")
exp_info<- readRDS("exp_info.rds")
```

## Reading in the Data
First we'll read in the data as a flowSet
```{r cache = TRUE,tidy = TRUE}
myflowset<- flowCore::read.flowSet(fcs_paths)
```
Then we'll convert it to a gatingSet
```{r}
mygatingset <- flowWorkspace::GatingSet(myflowset)
```

## Cytometry Preprocessing (Transformations, Gates, Panels) can be done in R

Next we'll:

- rescale the data using the defined asinh transformation for the approraite channels:
- rename the channels according to our panel
- apply gates to the gatingset
- convert the data back to a flowset
```{r}
mygatingset <- flowWorkspace::transform(mygatingset, exp_info$transforms)
markernames(mygatingset) <- exp_info$panels$`Panel 1`
CytoML::gating(exp_info$gates, mygatingset)
myflowset_preprocessed <- flowWorkspace::getData(mygatingset)
```

## Cytotidyr allows us to convert the flowset to a tidy data.frame

In order to work with our data using R, we'll need to convert it to a data frame, using the `as.data.frame` function from cytotidyr
```{r}
mydataframe <- as.data.frame(myflowset_preprocessed, use_longnames = T) %>%
  mutate(`FCS Filename` = basename(`FCS Filename`)) %>%
  mutate(Group = substr(`FCS Filename`, 13, 19))
str(mydataframe)
```


## Making Cytometry Figures in R (1)

One thing we may want to do is reproduce the same tSNE figure we made on cytobank:
```{r}
ggplot(mydataframe, aes(x = tSNE1, y = tSNE2)) + 
  geom_point(shape = ".") + 
  coord_fixed() + 
  facet_wrap(~Group) 
```


## Making Cytometry Figures in R (2)

We can also customize our plots in ways that are not easy to do in cytobank:
```{r}
ggplot(mydataframe, aes(x = tSNE1, y = tSNE2)) + 
  geom_point(shape = 16, alpha = 0.2, size = 0.2) + 
  coord_fixed() + 
  facet_wrap(~Group) + 
  scale_color_viridis_c(option = "A") + 
  theme_minimal() + 
  theme(axis.text = element_blank())
```

## Making Cytometry Figures in R (3)

We may also want to plot multiple channels in the same plot with faceting:

>- Two differences between this plot compared and the last plot:
>    - Marker intensity is mapped to color
>    - Markers are facetted across mutliple subplots

>- In our current [wide] data.frame, intensity is spread across multiple columns
>- The plot we want to make requires a [long] data.frame with a single column for intensity + a new column for markers 
>- We'll need to 'tidy' the data to the right format for our plot.

```{r cache = T}
dim((mydataframe))

element2 <- function(x){unlist(lapply(strsplit(x, split = "_|\ "),"[[", 2))}
mydataframe.long <- mydataframe %>% 
  as_tibble() %>%
  gather(marker, intensity, contains("(V)")) %>% # <- this is the key step
  separate(marker, c("channel", "marker", "drop"), sep= "_|\ ") %>%
  as_tibble()
dim((mydataframe.long))
```

## Making Cytometry Figures in R (4)

Then we'll make our plot: 

```{r}
mydataframe.long %>%
  ggplot(aes(x = tSNE1, y = tSNE2, col = intensity)) + 
  geom_point(shape = ".") + 
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) +
  scale_color_viridis_c(option = "A") + 
  coord_fixed() + 
  facet_wrap(~marker, nrow = 3) + 
  theme_minimal() + 
  theme(axis.text = element_blank())
```

## Applying alternative dimensionality reduction techniques (1)

One of the advantages of R is that we're not limited to the dimensionality reduction techniques that are included in commercial packages. 

>- Ex: Uniform Manifold Approximation and Projection (UMAP)
>    - McInnes L. et al. arXiv, 2018
    
>- Advantages of UMAP vs. tSNE
>   - Faster (minutes vs. hours)
>   - Scalable ($f(n)$ vs. $f(n*log(n))$)
>   - Preserves local+global structure
>   - Other nice features (embedding new points, supervised learning, etc...)


## Applying alternative dimensionality reduction techniques (2)

First we'll need to create a seperate matrix containing the columns we want to be included in the dimensionality reduction. 
```{r}
mymatrix <- mydataframe %>%
  select(contains("(V)")) %>%
  as.matrix()
```

Then we'll run it through the uwot implementation of UMAP
```{r}
#install.packages("devtools")
#devtools::install_github("jlmelville/uwot")
library(uwot)
myumap <- umap(mymatrix, init = "PCA")
str(myumap)
```

## Applying alternative dimensionality reduction techniques (3)

Next, we'll rejoin the two new UMAP columns to our original dataframe, and make our plot:

```{r, echo = FALSE}
colnames(myumap) <- c("UMAP1", "UMAP2")
#library(cytotidyr)
mydataframe %>%
  bind_cols(as.data.frame(myumap)) %>%
  ggplot(aes(x=UMAP1, y = UMAP2)) + 
  geom_point(shape = ".", alpha = 0.2) +
  facet_wrap(~Group) + 
  theme_classic() + 
  coord_fixed()
```


## Applying alternative dimensionality reduction techniques (4)

```{r}
mydataframe %>%
  bind_cols(as.data.frame(myumap)) %>%
  as_tibble() %>%
  gather(marker, intensity, contains("(V)")) %>% # <- this is the key step
  separate(marker, c("channel", "marker", "drop"), sep= "_|\ ") %>%
  ggplot(aes(x = UMAP1, y = UMAP2, col = intensity)) + 
  geom_point(shape = ".") + 
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) +
  scale_color_viridis_c(option = "A") + 
  coord_fixed() + 
  facet_wrap(~marker, nrow = 3) + 
  theme_minimal() + 
  theme(axis.text = element_blank())
```

## Applying alternative dimensionality reduction techniques (5)

We can also plot our data as a map:

```{r}
library(scico)
axis.max <- apply(myumap, 2, max) + 1
axis.min <- apply(myumap, 2, min) - 1

mydataframe %>%
  bind_cols(as.data.frame(myumap)) %>%
  ggplot(aes(x=UMAP1, y = UMAP2)) + 
  stat_density_2d(h = c(1, 1),
                  n = 1024, 
                  geom = "raster", 
                  contour = F,
                  aes(fill = stat(density))) + 
  scale_fill_scico(palette = "oleron", name = "density", trans = "sqrt") + 
  scale_x_continuous(expand = c(0,0), limits = c(axis.min[1], axis.max[1])) + 
  scale_y_continuous(expand = c(0,0), limits = c(axis.min[2], axis.max[2])) +
  theme_classic() + 
  coord_fixed()
```

## Clustering in R

We can also apply a clustering algorithm to our dimensionality reduced data. 

>- Density-based spatial clustering of applications with noise (DBSCAN)
>     - No need to specify number of clusters
>     - Few parameters to tune (eps and minPts) 
>     - Fast + scalable

```{r}
#install.packages("dbscan")
library(dbscan)
mydbscan <- dbscan(myumap, eps = 0.3, minPts = 150)
mydbscan
mydataframe %>%
  bind_cols(as.data.frame(myumap)) %>%
  mutate(cluster = as.factor(mydbscan$cluster)) %>%
 # dplyr::filter(cluster == 1:3) %>%
  ggplot(aes(x=UMAP1, y = UMAP2, col = cluster)) + 
  geom_point(shape = ".") + 
  scale_color_discrete(guide = guide_legend(override.aes = list(shape = 15))) + 
  coord_fixed() + 
  theme_classic()
```

## Understanding our clusters

We have clusters, but how can we understand what makes them distinct?

- Marker Enrichment Modeling (MEM)
- Heatmaps (see example below)

```{r cluster analysis}
library(tibble)
library(scico)
library(seriation)

myheatmap <- mydataframe %>%
  bind_cols(as.data.frame(myumap)) %>%
  mutate(cluster = as.factor(mydbscan$cluster)) %>%
  gather(marker, intensity, contains("(V)")) %>% # <- this is the key step
  group_by(cluster, marker) %>%
  summarise(MFI = median(intensity)) %>%
  select(marker, MFI, cluster) %>%
  spread(marker, MFI)

myheatmap.mat <- myheatmap %>%
  ungroup() %>%
  column_to_rownames("cluster") %>%
  as.matrix()

matrix.dist.row <- dist((myheatmap.mat))
matrix.dist.col <- dist(t(myheatmap.mat))
row.order <- seriation::get_order(seriate(matrix.dist.row, method = "HC"))
col.order <- seriation::get_order(seriate(matrix.dist.col, method = "HC"))

myheatmap %>%
  ungroup() %>%
  gather(marker, MFI, -cluster) %>%
  mutate(marker = factor(marker, levels = colnames(myheatmap.mat)[(col.order)])) %>%
  mutate(cluster = factor(cluster, levels = rownames(myheatmap.mat)[(row.order)])) %>%
  ggplot(aes(x=cluster, y = marker,fill = MFI)) + 
  geom_tile(color = "grey90", size = 0.5) + 
  scale_fill_viridis_c(option = "E") + 
  scale_x_discrete(expand = c(0,0)) + 
  scale_y_discrete(expand = c(0,0)) + 
  coord_fixed()
```


## What else is out there

<div style="float: left; width: 50%;">

[CyTOFkit](https://github.com/JinmiaoChenLab/cytofkit)


>-  Chen, H, et al., _PLOS Computational Biology_ 2016
>-  Integrated pipeline for analysing cytometry data in R

![](https://journals.plos.org/ploscompbiol/article/figure/image?size=large&id=10.1371/journal.pcbi.1005112.g001){ width=75% }

</div>
<div style="float: right; width: 50%;">

[CytoRSuite](https://dillonhammill.github.io/CytoRSuite/) 

>-  Set of interactive tools that integrate with flowWorkspace 
>-  *Interactive gating*, compensations, panels, etc...

![](https://dillonhammill.github.io/CytoRSuite/reference/figures/README-gate_draw.gif)

</div>

## Resources for Learning More

>- [Datacamp](https://www.datacamp.com/)
>- [R for Data Science - Hadley Wickham](https://r4ds.had.co.nz/)
>- Github [(London 2019)](https://github.com/bjreisman/bjreisman.github.io/tree/master/London2019)
